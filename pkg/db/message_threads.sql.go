// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: message_threads.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getThreadMessages = `-- name: GetThreadMessages :many
SELECT
    m.id, m.device_id, m.user_id, m.recipient, m.recipient_type,
    m.message_type, m.content, m.media_url, m.media_filename,
    m.buttons, m.template_id, m.status, m.sent_at, m.delivered_at,
    m.read_at, m.direction, m.wa_message_id, m.sender_jid,
    COALESCE(wc.full_name, wc.push_name, '') AS sender_name
FROM message_logs m
LEFT JOIN whatsapp_contacts wc ON wc.device_id = m.device_id AND wc.jid = m.sender_jid
WHERE m.device_id = $1 AND m.recipient = $2
ORDER BY m.sent_at ASC
LIMIT $3 OFFSET $4
`

type GetThreadMessagesParams struct {
	DeviceID  pgtype.Text `json:"device_id"`
	Recipient string      `json:"recipient"`
	Limit     int64       `json:"limit"`
	Offset    int64       `json:"offset"`
}

type GetThreadMessagesRow struct {
	ID            pgtype.UUID        `json:"id"`
	DeviceID      pgtype.Text        `json:"device_id"`
	UserID        pgtype.Int4        `json:"user_id"`
	Recipient     string             `json:"recipient"`
	RecipientType pgtype.Text        `json:"recipient_type"`
	MessageType   pgtype.Text        `json:"message_type"`
	Content       string             `json:"content"`
	MediaUrl      pgtype.Text        `json:"media_url"`
	MediaFilename pgtype.Text        `json:"media_filename"`
	Buttons       []byte             `json:"buttons"`
	TemplateID    pgtype.UUID        `json:"template_id"`
	Status        pgtype.Text        `json:"status"`
	SentAt        pgtype.Timestamptz `json:"sent_at"`
	DeliveredAt   pgtype.Timestamptz `json:"delivered_at"`
	ReadAt        pgtype.Timestamptz `json:"read_at"`
	Direction     string             `json:"direction"`
	WaMessageID   pgtype.Text        `json:"wa_message_id"`
	SenderJid     pgtype.Text        `json:"sender_jid"`
	SenderName    string             `json:"sender_name"`
}

func (q *Queries) GetThreadMessages(ctx context.Context, arg GetThreadMessagesParams) ([]GetThreadMessagesRow, error) {
	rows, err := q.db.Query(ctx, getThreadMessages,
		arg.DeviceID,
		arg.Recipient,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetThreadMessagesRow
	for rows.Next() {
		var i GetThreadMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.UserID,
			&i.Recipient,
			&i.RecipientType,
			&i.MessageType,
			&i.Content,
			&i.MediaUrl,
			&i.MediaFilename,
			&i.Buttons,
			&i.TemplateID,
			&i.Status,
			&i.SentAt,
			&i.DeliveredAt,
			&i.ReadAt,
			&i.Direction,
			&i.WaMessageID,
			&i.SenderJid,
			&i.SenderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreads = `-- name: GetThreads :many
SELECT
    t.id,
    t.device_id,
    t.chat_jid,
    t.chat_type,
    t.last_message_at,
    t.last_message_content,
    t.last_message_type,
    t.last_message_direction,
    t.unread_count,
    COALESCE(wc.full_name, wc.push_name, wg.group_name, '') AS chat_name
FROM message_threads t
LEFT JOIN whatsapp_contacts wc ON wc.device_id = t.device_id AND wc.jid = t.chat_jid
LEFT JOIN whatsapp_groups wg ON wg.device_id = t.device_id AND wg.group_id = t.chat_jid
WHERE t.device_id = $1
ORDER BY t.last_message_at DESC
LIMIT $3 OFFSET $2
`

type GetThreadsParams struct {
	DeviceID    string `json:"device_id"`
	QueryOffset int64  `json:"query_offset"`
	QueryLimit  int64  `json:"query_limit"`
}

type GetThreadsRow struct {
	ID                   pgtype.UUID        `json:"id"`
	DeviceID             string             `json:"device_id"`
	ChatJid              string             `json:"chat_jid"`
	ChatType             string             `json:"chat_type"`
	LastMessageAt        pgtype.Timestamptz `json:"last_message_at"`
	LastMessageContent   string             `json:"last_message_content"`
	LastMessageType      string             `json:"last_message_type"`
	LastMessageDirection string             `json:"last_message_direction"`
	UnreadCount          int32              `json:"unread_count"`
	ChatName             string             `json:"chat_name"`
}

func (q *Queries) GetThreads(ctx context.Context, arg GetThreadsParams) ([]GetThreadsRow, error) {
	rows, err := q.db.Query(ctx, getThreads, arg.DeviceID, arg.QueryOffset, arg.QueryLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetThreadsRow
	for rows.Next() {
		var i GetThreadsRow
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.ChatJid,
			&i.ChatType,
			&i.LastMessageAt,
			&i.LastMessageContent,
			&i.LastMessageType,
			&i.LastMessageDirection,
			&i.UnreadCount,
			&i.ChatName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetThreadUnread = `-- name: ResetThreadUnread :exec
UPDATE message_threads
SET unread_count = 0, updated_at = NOW()
WHERE device_id = $1 AND chat_jid = $2
`

type ResetThreadUnreadParams struct {
	DeviceID string `json:"device_id"`
	ChatJid  string `json:"chat_jid"`
}

func (q *Queries) ResetThreadUnread(ctx context.Context, arg ResetThreadUnreadParams) error {
	_, err := q.db.Exec(ctx, resetThreadUnread, arg.DeviceID, arg.ChatJid)
	return err
}

const upsertThread = `-- name: UpsertThread :exec
INSERT INTO message_threads (device_id, chat_jid, chat_type, last_message_at, last_message_content, last_message_type, last_message_direction, unread_count)
VALUES ($1, $2, $3, NOW(), $4, $5, $6,
    CASE WHEN $7::bool THEN 1 ELSE 0 END
)
ON CONFLICT (device_id, chat_jid) DO UPDATE SET
    last_message_at = NOW(),
    last_message_content = EXCLUDED.last_message_content,
    last_message_type = EXCLUDED.last_message_type,
    last_message_direction = EXCLUDED.last_message_direction,
    unread_count = CASE
        WHEN EXCLUDED.last_message_direction = 'incoming'
        THEN message_threads.unread_count + 1
        ELSE message_threads.unread_count
    END,
    updated_at = NOW()
`

type UpsertThreadParams struct {
	DeviceID    string `json:"device_id"`
	ChatJid     string `json:"chat_jid"`
	ChatType    string `json:"chat_type"`
	Content     string `json:"content"`
	MessageType string `json:"message_type"`
	Direction   string `json:"direction"`
	IsIncoming  bool   `json:"is_incoming"`
}

func (q *Queries) UpsertThread(ctx context.Context, arg UpsertThreadParams) error {
	_, err := q.db.Exec(ctx, upsertThread,
		arg.DeviceID,
		arg.ChatJid,
		arg.ChatType,
		arg.Content,
		arg.MessageType,
		arg.Direction,
		arg.IsIncoming,
	)
	return err
}
