// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: message_logs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getConversationMessages = `-- name: GetConversationMessages :many
SELECT 
    m.id, m.device_id, m.user_id, m.recipient, m.recipient_type, m.message_type, m.content, m.media_url, m.media_filename, m.buttons, m.template_id, m.status, m.sent_at, m.delivered_at, m.read_at, m.direction, m.wa_message_id, m.sender_jid,
    COALESCE(wc.full_name, wc.push_name, '') AS sender_name
FROM message_logs m
LEFT JOIN whatsapp_contacts wc ON wc.device_id = m.device_id AND wc.jid = m.sender_jid
WHERE m.device_id = $1 AND m.recipient = $2
ORDER BY m.sent_at ASC
LIMIT $3 OFFSET $4
`

type GetConversationMessagesParams struct {
	DeviceID  pgtype.Text `json:"device_id"`
	Recipient string      `json:"recipient"`
	Limit     int64       `json:"limit"`
	Offset    int64       `json:"offset"`
}

type GetConversationMessagesRow struct {
	ID            pgtype.UUID        `json:"id"`
	DeviceID      pgtype.Text        `json:"device_id"`
	UserID        pgtype.Int4        `json:"user_id"`
	Recipient     string             `json:"recipient"`
	RecipientType pgtype.Text        `json:"recipient_type"`
	MessageType   pgtype.Text        `json:"message_type"`
	Content       string             `json:"content"`
	MediaUrl      pgtype.Text        `json:"media_url"`
	MediaFilename pgtype.Text        `json:"media_filename"`
	Buttons       []byte             `json:"buttons"`
	TemplateID    pgtype.UUID        `json:"template_id"`
	Status        pgtype.Text        `json:"status"`
	SentAt        pgtype.Timestamptz `json:"sent_at"`
	DeliveredAt   pgtype.Timestamptz `json:"delivered_at"`
	ReadAt        pgtype.Timestamptz `json:"read_at"`
	Direction     string             `json:"direction"`
	WaMessageID   pgtype.Text        `json:"wa_message_id"`
	SenderJid     pgtype.Text        `json:"sender_jid"`
	SenderName    string             `json:"sender_name"`
}

func (q *Queries) GetConversationMessages(ctx context.Context, arg GetConversationMessagesParams) ([]GetConversationMessagesRow, error) {
	rows, err := q.db.Query(ctx, getConversationMessages,
		arg.DeviceID,
		arg.Recipient,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConversationMessagesRow
	for rows.Next() {
		var i GetConversationMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.UserID,
			&i.Recipient,
			&i.RecipientType,
			&i.MessageType,
			&i.Content,
			&i.MediaUrl,
			&i.MediaFilename,
			&i.Buttons,
			&i.TemplateID,
			&i.Status,
			&i.SentAt,
			&i.DeliveredAt,
			&i.ReadAt,
			&i.Direction,
			&i.WaMessageID,
			&i.SenderJid,
			&i.SenderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversations = `-- name: GetConversations :many
SELECT
  m.recipient,
  m.recipient_type,
  m.sent_at AS last_message_at,
  m.content AS last_message_content,
  m.direction AS last_message_direction,
  COALESCE(
    (SELECT COUNT(*) FROM message_logs u
     WHERE u.device_id = m.device_id AND u.recipient = m.recipient
       AND u.direction = 'incoming' AND u.status != 'read'), 0
  )::int AS unread_count,
  COALESCE(wc.full_name, wc.push_name, wg.group_name, '') AS recipient_name
FROM message_logs m
INNER JOIN (
  SELECT recipient, MAX(sent_at) AS max_sent_at
  FROM message_logs
  WHERE device_id = $1
  GROUP BY recipient
) latest ON m.recipient = latest.recipient AND m.sent_at = latest.max_sent_at
LEFT JOIN whatsapp_contacts wc ON wc.device_id = m.device_id AND wc.jid = m.recipient
LEFT JOIN whatsapp_groups wg ON wg.device_id = m.device_id AND wg.group_id = m.recipient
WHERE m.device_id = $1
ORDER BY m.sent_at DESC
LIMIT $3 OFFSET $2
`

type GetConversationsParams struct {
	DeviceID    pgtype.Text `json:"device_id"`
	QueryOffset pgtype.Int8 `json:"query_offset"`
	QueryLimit  pgtype.Int8 `json:"query_limit"`
}

type GetConversationsRow struct {
	Recipient            string             `json:"recipient"`
	RecipientType        pgtype.Text        `json:"recipient_type"`
	LastMessageAt        pgtype.Timestamptz `json:"last_message_at"`
	LastMessageContent   string             `json:"last_message_content"`
	LastMessageDirection string             `json:"last_message_direction"`
	UnreadCount          int32              `json:"unread_count"`
	RecipientName        string             `json:"recipient_name"`
}

func (q *Queries) GetConversations(ctx context.Context, arg GetConversationsParams) ([]GetConversationsRow, error) {
	rows, err := q.db.Query(ctx, getConversations, arg.DeviceID, arg.QueryOffset, arg.QueryLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConversationsRow
	for rows.Next() {
		var i GetConversationsRow
		if err := rows.Scan(
			&i.Recipient,
			&i.RecipientType,
			&i.LastMessageAt,
			&i.LastMessageContent,
			&i.LastMessageDirection,
			&i.UnreadCount,
			&i.RecipientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessageHistory = `-- name: GetMessageHistory :many
SELECT id, device_id, user_id, recipient, recipient_type, message_type, content, media_url, media_filename, buttons, template_id, status, sent_at, delivered_at, read_at, direction, wa_message_id, sender_jid
FROM message_logs
WHERE user_id = $1
ORDER BY sent_at DESC
LIMIT $2
`

type GetMessageHistoryParams struct {
	UserID pgtype.Int4 `json:"user_id"`
	Limit  int64       `json:"limit"`
}

func (q *Queries) GetMessageHistory(ctx context.Context, arg GetMessageHistoryParams) ([]MessageLog, error) {
	rows, err := q.db.Query(ctx, getMessageHistory, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessageLog
	for rows.Next() {
		var i MessageLog
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.UserID,
			&i.Recipient,
			&i.RecipientType,
			&i.MessageType,
			&i.Content,
			&i.MediaUrl,
			&i.MediaFilename,
			&i.Buttons,
			&i.TemplateID,
			&i.Status,
			&i.SentAt,
			&i.DeliveredAt,
			&i.ReadAt,
			&i.Direction,
			&i.WaMessageID,
			&i.SenderJid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logIncomingMessage = `-- name: LogIncomingMessage :one
INSERT INTO message_logs (device_id, recipient, recipient_type, message_type, content, media_url, media_filename, status, direction, sender_jid, wa_message_id)
VALUES ($1, $2, $3, $4, $5, $6::text, $7::varchar(255), 'delivered', 'incoming', $8, $9)
RETURNING id, device_id, user_id, recipient, recipient_type, message_type, content, media_url, media_filename, buttons, template_id, status, sent_at, delivered_at, read_at, direction, wa_message_id, sender_jid
`

type LogIncomingMessageParams struct {
	DeviceID      pgtype.Text `json:"device_id"`
	Recipient     string      `json:"recipient"`
	RecipientType pgtype.Text `json:"recipient_type"`
	MessageType   pgtype.Text `json:"message_type"`
	Content       string      `json:"content"`
	Column6       string      `json:"column_6"`
	Column7       string      `json:"column_7"`
	SenderJid     pgtype.Text `json:"sender_jid"`
	WaMessageID   pgtype.Text `json:"wa_message_id"`
}

func (q *Queries) LogIncomingMessage(ctx context.Context, arg LogIncomingMessageParams) (MessageLog, error) {
	row := q.db.QueryRow(ctx, logIncomingMessage,
		arg.DeviceID,
		arg.Recipient,
		arg.RecipientType,
		arg.MessageType,
		arg.Content,
		arg.Column6,
		arg.Column7,
		arg.SenderJid,
		arg.WaMessageID,
	)
	var i MessageLog
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.UserID,
		&i.Recipient,
		&i.RecipientType,
		&i.MessageType,
		&i.Content,
		&i.MediaUrl,
		&i.MediaFilename,
		&i.Buttons,
		&i.TemplateID,
		&i.Status,
		&i.SentAt,
		&i.DeliveredAt,
		&i.ReadAt,
		&i.Direction,
		&i.WaMessageID,
		&i.SenderJid,
	)
	return i, err
}

const logOutgoingMessage = `-- name: LogOutgoingMessage :one
INSERT INTO message_logs (device_id, recipient, recipient_type, message_type, content, media_url, media_filename, status, direction, wa_message_id)
VALUES ($1, $2, $3, $4, $5, $6::text, $7::varchar(255), 'sent', 'outgoing', $8)
RETURNING id, device_id, user_id, recipient, recipient_type, message_type, content, media_url, media_filename, buttons, template_id, status, sent_at, delivered_at, read_at, direction, wa_message_id, sender_jid
`

type LogOutgoingMessageParams struct {
	DeviceID      pgtype.Text `json:"device_id"`
	Recipient     string      `json:"recipient"`
	RecipientType pgtype.Text `json:"recipient_type"`
	MessageType   pgtype.Text `json:"message_type"`
	Content       string      `json:"content"`
	Column6       string      `json:"column_6"`
	Column7       string      `json:"column_7"`
	WaMessageID   pgtype.Text `json:"wa_message_id"`
}

func (q *Queries) LogOutgoingMessage(ctx context.Context, arg LogOutgoingMessageParams) (MessageLog, error) {
	row := q.db.QueryRow(ctx, logOutgoingMessage,
		arg.DeviceID,
		arg.Recipient,
		arg.RecipientType,
		arg.MessageType,
		arg.Content,
		arg.Column6,
		arg.Column7,
		arg.WaMessageID,
	)
	var i MessageLog
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.UserID,
		&i.Recipient,
		&i.RecipientType,
		&i.MessageType,
		&i.Content,
		&i.MediaUrl,
		&i.MediaFilename,
		&i.Buttons,
		&i.TemplateID,
		&i.Status,
		&i.SentAt,
		&i.DeliveredAt,
		&i.ReadAt,
		&i.Direction,
		&i.WaMessageID,
		&i.SenderJid,
	)
	return i, err
}

const markConversationRead = `-- name: MarkConversationRead :exec
UPDATE message_logs
SET status = 'read'
WHERE device_id = $1 AND recipient = $2 AND direction = 'incoming' AND status != 'read'
`

type MarkConversationReadParams struct {
	DeviceID  pgtype.Text `json:"device_id"`
	Recipient string      `json:"recipient"`
}

func (q *Queries) MarkConversationRead(ctx context.Context, arg MarkConversationReadParams) error {
	_, err := q.db.Exec(ctx, markConversationRead, arg.DeviceID, arg.Recipient)
	return err
}

const sendMessageData = `-- name: SendMessageData :one
INSERT INTO message_logs (device_id,
                          user_id,
                          recipient,
                          recipient_type,
                          message_type,
                          content,
                          media_url,
                          media_filename,
                          buttons,
                          status)
VALUES ($1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7::text, -- or NULL
        $8::varchar(255), -- or NULL
        $9::jsonb, -- or NULL
        'sent')
RETURNING id, device_id, user_id, recipient, recipient_type, message_type, content, media_url, media_filename, buttons, template_id, status, sent_at, delivered_at, read_at, direction, wa_message_id, sender_jid
`

type SendMessageDataParams struct {
	DeviceID      pgtype.Text `json:"device_id"`
	UserID        pgtype.Int4 `json:"user_id"`
	Recipient     string      `json:"recipient"`
	RecipientType pgtype.Text `json:"recipient_type"`
	MessageType   pgtype.Text `json:"message_type"`
	Content       string      `json:"content"`
	Column7       string      `json:"column_7"`
	Column8       string      `json:"column_8"`
	Column9       []byte      `json:"column_9"`
}

func (q *Queries) SendMessageData(ctx context.Context, arg SendMessageDataParams) (MessageLog, error) {
	row := q.db.QueryRow(ctx, sendMessageData,
		arg.DeviceID,
		arg.UserID,
		arg.Recipient,
		arg.RecipientType,
		arg.MessageType,
		arg.Content,
		arg.Column7,
		arg.Column8,
		arg.Column9,
	)
	var i MessageLog
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.UserID,
		&i.Recipient,
		&i.RecipientType,
		&i.MessageType,
		&i.Content,
		&i.MediaUrl,
		&i.MediaFilename,
		&i.Buttons,
		&i.TemplateID,
		&i.Status,
		&i.SentAt,
		&i.DeliveredAt,
		&i.ReadAt,
		&i.Direction,
		&i.WaMessageID,
		&i.SenderJid,
	)
	return i, err
}

const updateMessageStatus = `-- name: UpdateMessageStatus :exec
UPDATE message_logs SET status = $2 WHERE wa_message_id = $1
`

type UpdateMessageStatusParams struct {
	WaMessageID pgtype.Text `json:"wa_message_id"`
	Status      pgtype.Text `json:"status"`
}

func (q *Queries) UpdateMessageStatus(ctx context.Context, arg UpdateMessageStatusParams) error {
	_, err := q.db.Exec(ctx, updateMessageStatus, arg.WaMessageID, arg.Status)
	return err
}
